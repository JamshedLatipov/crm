<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FreeSWITCH WebRTC Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    .status.disconnected { background: #ffebee; color: #c62828; }
    .status.connecting { background: #fff3e0; color: #ef6c00; }
    .status.connected { background: #e8f5e9; color: #2e7d32; }
    .controls {
      margin: 20px 0;
    }
    input, button {
      padding: 10px;
      margin: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    button {
      background: #2196f3;
      color: white;
      border: none;
      cursor: pointer;
      min-width: 120px;
    }
    button:hover { background: #1976d2; }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .dial-pad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-width: 300px;
      margin: 20px 0;
    }
    .dial-pad button {
      padding: 20px;
      font-size: 18px;
      font-weight: bold;
    }
    #logs {
      background: #263238;
      color: #aed581;
      padding: 15px;
      border-radius: 4px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }
    .log-entry {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid #37474f;
    }
    audio {
      width: 100%;
      margin: 10px 0;
    }
    .device-info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #2196f3;
    }
    .error-box {
      background: #ffebee;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #f44336;
      color: #c62828;
    }
    .success-box {
      background: #e8f5e9;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #4caf50;
      color: #2e7d32;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>FreeSWITCH WebRTC Client</h1>
    
    <div id="deviceCheck" class="device-info">
      <h4>Проверка устройств...</h4>
      <div id="deviceList"></div>
      <button onclick="checkDevices()" style="margin-top: 10px;">Проверить устройства</button>
      <button onclick="testMicrophone()" style="margin-top: 10px;">Тест микрофона</button>
    </div>
    
    <div class="status disconnected" id="status">Disconnected</div>
    
    <div class="controls">
      <h3>Connection</h3>
      <input type="text" id="server" value="ws://localhost:8081" placeholder="WebSocket URL" style="width: 300px;">
      <input type="text" id="extension" value="1000" placeholder="Extension">
      <input type="password" id="password" value="1234" placeholder="Password">
      <button id="connectBtn" onclick="connect()">Connect</button>
      <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
    
    <div class="controls">
      <h3>Call Control</h3>
      <input type="text" id="destination" value="9999" placeholder="Destination (9999 for echo test)">
      <button id="callBtn" onclick="makeCall()" disabled>Call</button>
      <button id="hangupBtn" onclick="hangup()" disabled>Hangup</button>
      <button id="muteBtn" onclick="toggleMute()" disabled>Mute</button>
    </div>

    <div class="dial-pad">
      <button onclick="sendDTMF('1')">1</button>
      <button onclick="sendDTMF('2')">2</button>
      <button onclick="sendDTMF('3')">3</button>
      <button onclick="sendDTMF('4')">4</button>
      <button onclick="sendDTMF('5')">5</button>
      <button onclick="sendDTMF('6')">6</button>
      <button onclick="sendDTMF('7')">7</button>
      <button onclick="sendDTMF('8')">8</button>
      <button onclick="sendDTMF('9')">9</button>
      <button onclick="sendDTMF('*')">*</button>
      <button onclick="sendDTMF('0')">0</button>
      <button onclick="sendDTMF('#')">#</button>
    </div>

    <audio id="remoteAudio" autoplay playsinline></audio>
    <audio id="localAudio" muted playsinline></audio>

    <h3>Logs</h3>
    <div id="logs"></div>
  </div>

  <!-- Include Verto library from CDN or local -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery.jsonrpcclient@0.1.1/jquery.jsonrpcclient.min.js"></script>
  
  <script>
    let vertoHandle = null;
    let currentCall = null;
    let isMuted = false;

    // Проверка доступных устройств при загрузке
    window.addEventListener('load', () => {
      checkDevices();
    });

    async function checkDevices() {
      const deviceList = document.getElementById('deviceList');
      deviceList.innerHTML = '<p>Проверка устройств...</p>';
      
      try {
        // Сначала запрашиваем разрешение
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        log('✓ Разрешение на доступ к микрофону получено');
        
        // Останавливаем поток
        stream.getTracks().forEach(track => track.stop());
        
        // Получаем список устройств
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        
        if (audioInputs.length === 0) {
          deviceList.innerHTML = `
            <div class="error-box">
              <strong>⚠️ Микрофоны не найдены!</strong>
              <p>Убедитесь что:</p>
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Микрофон подключен к компьютеру</li>
                <li>Микрофон включен в настройках системы</li>
                <li>Другие приложения не блокируют доступ к микрофону</li>
              </ul>
            </div>
          `;
          log('❌ Аудио устройства не найдены');
        } else {
          let html = `<div class="success-box"><strong>✓ Найдено микрофонов: ${audioInputs.length}</strong><ul style="margin: 10px 0; padding-left: 20px;">`;
          audioInputs.forEach((device, index) => {
            html += `<li>${device.label || `Микрофон ${index + 1}`} (ID: ${device.deviceId.substring(0, 20)}...)</li>`;
            log(`✓ Найден микрофон: ${device.label || `Устройство ${index + 1}`}`);
          });
          html += '</ul></div>';
          deviceList.innerHTML = html;
        }
      } catch (error) {
        let errorMessage = '';
        let suggestions = '';
        
        switch(error.name) {
          case 'NotFoundError':
            errorMessage = 'Микрофон не найден';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Подключите микрофон к компьютеру</li>
                <li>Проверьте, что микрофон включен в настройках Windows (Параметры → Система → Звук)</li>
                <li>Перезагрузите браузер после подключения микрофона</li>
              </ul>
            `;
            break;
          case 'NotAllowedError':
          case 'PermissionDeniedError':
            errorMessage = 'Доступ к микрофону запрещён';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Нажмите на иконку замка/камеры в адресной строке браузера</li>
                <li>Разрешите доступ к микрофону для этого сайта</li>
                <li>Перезагрузите страницу после изменения разрешений</li>
              </ul>
            `;
            break;
          case 'NotReadableError':
            errorMessage = 'Микрофон используется другим приложением';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Закройте другие приложения, использующие микрофон (Skype, Zoom, Discord и т.д.)</li>
                <li>Закройте другие вкладки браузера с доступом к микрофону</li>
                <li>Перезагрузите компьютер, если проблема сохраняется</li>
              </ul>
            `;
            break;
          default:
            errorMessage = error.message || 'Неизвестная ошибка';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Попробуйте использовать другой браузер (Chrome, Firefox, Edge)</li>
                <li>Обновите браузер до последней версии</li>
                <li>Проверьте настройки антивируса</li>
              </ul>
            `;
        }
        
        deviceList.innerHTML = `
          <div class="error-box">
            <strong>❌ Ошибка: ${errorMessage}</strong>
            <p><code>Тип ошибки: ${error.name}</code></p>
            <p><strong>Возможные решения:</strong></p>
            ${suggestions}
          </div>
        `;
        log(`❌ Ошибка доступа к микрофону: ${error.name} - ${error.message}`);
        console.error('Microphone error details:', error);
      }
    }

    async function testMicrophone() {
      log('Тестирование микрофона...');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        log('✓ Микрофон работает! Тестовый поток получен');
        
        // Показываем уровень звука
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        const microphone = audioContext.createMediaStreamSource(stream);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        microphone.connect(analyser);
        
        let checkCount = 0;
        const checkInterval = setInterval(() => {
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
          log(`Уровень звука: ${Math.round(average)}/255 ${average > 10 ? '🔊' : '🔇'}`);
          
          checkCount++;
          if (checkCount >= 5) {
            clearInterval(checkInterval);
            stream.getTracks().forEach(track => track.stop());
            audioContext.close();
            log('✓ Тест микрофона завершён');
          }
        }, 500);
        
      } catch (error) {
        log(`❌ Тест не пройден: ${error.name} - ${error.message}`);
        console.error('Microphone test failed:', error);
      }
    }

    // Simple Verto implementation (simplified for demo)
    class VertoClient {
      constructor(config) {
        this.config = config;
        this.ws = null;
        this.sessid = null;
        this.pc = null;
        this.currentCallID = null;
      }

      connect() {
        return new Promise((resolve, reject) => {
          log('Connecting to ' + this.config.socketUrl);
          this.ws = new WebSocket(this.config.socketUrl);
          
          this.ws.onopen = () => {
            log('WebSocket connected');
            this.login().then(resolve).catch(reject);
          };

          this.ws.onerror = (error) => {
            log('WebSocket error: ' + error);
            reject(error);
          };

          this.ws.onmessage = (event) => {
            this.handleMessage(JSON.parse(event.data));
          };

          this.ws.onclose = () => {
            log('WebSocket closed');
            updateStatus('disconnected');
          };
        });
      }

      login() {
        const sessid = this.generateSessid();
        this.sessid = sessid;
        
        log(`Attempting login as ${this.config.login}@${this.config.domain}`);
        
        return this.sendRequest('login', {
          login: `${this.config.login}@${this.config.domain}`,
          passwd: this.config.password,
          sessid: sessid
        }).then((response) => {
          log(`Login request sent with sessid: ${sessid}`);
          return response;
        });
      }

      call(destination) {
        log('Calling ' + destination);
        
        const callID = this.generateSessid();
        
        const pc = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:localhost:3478', username: 'webrtc', credential: 'webrtcpass' }
          ]
        });

        this.pc = pc;
        this.currentCallID = callID;

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            log('ICE candidate: ' + event.candidate.candidate);
          } else {
            log('ICE gathering complete');
          }
        };

        pc.ontrack = (event) => {
          log('Remote stream received');
          document.getElementById('remoteAudio').srcObject = event.streams[0];
        };

        log('Requesting microphone access...');
        return navigator.mediaDevices.getUserMedia({ audio: true, video: false })
          .then(stream => {
            log('✓ Local stream obtained');
            document.getElementById('localAudio').srcObject = stream;
            stream.getTracks().forEach(track => {
              pc.addTrack(track, stream);
              log(`Added track: ${track.kind} (${track.label})`);
            });
            return pc.createOffer();
          })
          .catch(error => {
            log(`❌ Failed to get microphone: ${error.name} - ${error.message}`);
            throw error;
          })
          .then(offer => {
            log('Offer created');
            return pc.setLocalDescription(offer);
          })
          .then(() => {
            return this.sendRequest('verto.invite', {
              sessid: this.sessid,
              sdp: this.pc.localDescription.sdp,
              callID: callID,
              dialogParams: {
                destination_number: destination,
                caller_id_name: this.config.login,
                caller_id_number: this.config.login,
                useVideo: false,
                useStereo: false,
                screenShare: false,
                useCamera: false,
                useMic: true,
                dedEnc: false,
                mirrorInput: false
              }
            });
          });
      }

      hangup() {
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
        if (this.currentCallID) {
          return this.sendRequest('verto.bye', {
            sessid: this.sessid,
            callID: this.currentCallID
          });
        }
      }

      sendDTMF(digit) {
        if (this.pc) {
          const sender = this.pc.getSenders().find(s => s.track && s.track.kind === 'audio');
          if (sender && sender.dtmf) {
            sender.dtmf.insertDTMF(digit);
            log('Sent DTMF: ' + digit);
          }
        }
      }

      sendRequest(method, params) {
        const msg = {
          jsonrpc: '2.0',
          method: method,
          params: params || {},
          id: Date.now()
        };
        
        log('Sending: ' + method);
        this.ws.send(JSON.stringify(msg));
        
        return new Promise((resolve, reject) => {
          // Simple timeout-based resolution (proper implementation would track request IDs)
          setTimeout(() => resolve(), 1000);
        });
      }

      handleMessage(msg) {
        log('Received: ' + JSON.stringify(msg));
        console.log('Full Verto message:', msg);
        
        if (msg.error) {
          log(`❌ Error: ${msg.error.message} (code: ${msg.error.code})`);
          console.error('Verto error details:', msg.error);
          return;
        }
        
        if (msg.method === 'verto.answer' && msg.params && msg.params.sdp) {
          log('Setting remote description from answer');
          this.pc.setRemoteDescription({
            type: 'answer',
            sdp: msg.params.sdp
          }).then(() => {
            log('✓ Call answered and connected');
          }).catch(err => {
            log(`❌ Failed to set remote description: ${err}`);
          });
        } else if (msg.method === 'verto.bye') {
          log('Call ended by remote');
          if (this.pc) {
            this.pc.close();
            this.pc = null;
          }
          updateCallButtons(false);
        } else if (msg.result) {
          if (msg.result.message === 'logged in' || msg.result.message) {
            this.sessid = msg.result.sessid || this.sessid;
            log(`✓ ${msg.result.message} - sessid: ${this.sessid}`);
            updateStatus('connected');
          } else {
            log(`Result: ${JSON.stringify(msg.result)}`);
          }
        }
      }

      generateSessid() {
        return Math.random().toString(36).substring(2, 15);
      }

      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
      }
    }

    function log(message) {
      const logs = document.getElementById('logs');
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = new Date().toLocaleTimeString() + ' - ' + message;
      logs.appendChild(entry);
      logs.scrollTop = logs.scrollHeight;
    }

    function updateStatus(status) {
      const statusEl = document.getElementById('status');
      statusEl.className = 'status ' + status;
      statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      
      document.getElementById('connectBtn').disabled = (status === 'connected');
      document.getElementById('disconnectBtn').disabled = (status === 'disconnected');
      document.getElementById('callBtn').disabled = (status !== 'connected');
    }

    function updateCallButtons(inCall) {
      document.getElementById('callBtn').disabled = inCall;
      document.getElementById('hangupBtn').disabled = !inCall;
      document.getElementById('muteBtn').disabled = !inCall;
    }

    function connect() {
      const server = document.getElementById('server').value;
      const extension = document.getElementById('extension').value;
      const password = document.getElementById('password').value;
      
      updateStatus('connecting');
      
      vertoHandle = new VertoClient({
        socketUrl: server,
        login: extension,
        password: password,
        domain: server.includes('localhost') ? 'auto' : 'localhost'  // Используем 'auto' для localhost
      });
      
      vertoHandle.connect()
        .then(() => {
          log('Successfully connected and logged in');
        })
        .catch(error => {
          log('Connection failed: ' + error);
          updateStatus('disconnected');
        });
    }

    function disconnect() {
      if (vertoHandle) {
        vertoHandle.disconnect();
        vertoHandle = null;
      }
      updateStatus('disconnected');
      updateCallButtons(false);
    }

    function makeCall() {
      const destination = document.getElementById('destination').value;
      if (vertoHandle && destination) {
        log(`Initiating call to ${destination}...`);
        vertoHandle.call(destination)
          .then(() => {
            log('✓ Call initiated to ' + destination);
            updateCallButtons(true);
          })
          .catch(error => {
            log(`❌ Call failed: ${error.name} - ${error.message}`);
            console.error('Call error:', error);
            alert(`Не удалось совершить звонок:\n${error.name}: ${error.message}\n\nПроверьте доступ к микрофону и попробуйте снова.`);
          });
      }
    }

    function hangup() {
      if (vertoHandle) {
        vertoHandle.hangup()
          .then(() => {
            log('Call ended');
            updateCallButtons(false);
          });
      }
    }

    function toggleMute() {
      if (vertoHandle && vertoHandle.pc) {
        const audioTrack = document.getElementById('localAudio').srcObject.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          document.getElementById('muteBtn').textContent = isMuted ? 'Unmute' : 'Mute';
          log(isMuted ? 'Muted' : 'Unmuted');
        }
      }
    }

    function sendDTMF(digit) {
      if (vertoHandle) {
        vertoHandle.sendDTMF(digit);
      }
    }

    // Initialize
    log('WebRTC client ready');
    updateStatus('disconnected');
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FreeSWITCH WebRTC Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    .status.disconnected { background: #ffebee; color: #c62828; }
    .status.connecting { background: #fff3e0; color: #ef6c00; }
    .status.connected { background: #e8f5e9; color: #2e7d32; }
    .controls {
      margin: 20px 0;
    }
    input, button {
      padding: 10px;
      margin: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    button {
      background: #2196f3;
      color: white;
      border: none;
      cursor: pointer;
      min-width: 120px;
    }
    button:hover { background: #1976d2; }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .dial-pad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-width: 300px;
      margin: 20px 0;
    }
    .dial-pad button {
      padding: 20px;
      font-size: 18px;
      font-weight: bold;
    }
    #logs {
      background: #263238;
      color: #aed581;
      padding: 15px;
      border-radius: 4px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }
    .log-entry {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid #37474f;
    }
    audio {
      width: 100%;
      margin: 10px 0;
    }
    .device-info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #2196f3;
    }
    .error-box {
      background: #ffebee;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #f44336;
      color: #c62828;
    }
    .success-box {
      background: #e8f5e9;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid #4caf50;
      color: #2e7d32;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>FreeSWITCH WebRTC Client</h1>
    
    <div id="deviceCheck" class="device-info">
      <h4>–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤...</h4>
      <div id="deviceList"></div>
      <button onclick="checkDevices()" style="margin-top: 10px;">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞</button>
      <button onclick="testMicrophone()" style="margin-top: 10px;">–¢–µ—Å—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞</button>
    </div>
    
    <div class="status disconnected" id="status">Disconnected</div>
    
    <div class="controls">
      <h3>Connection</h3>
      <input type="text" id="server" value="ws://localhost:8081" placeholder="WebSocket URL" style="width: 300px;">
      <input type="text" id="extension" value="1000" placeholder="Extension">
      <input type="password" id="password" value="1234" placeholder="Password">
      <button id="connectBtn" onclick="connect()">Connect</button>
      <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
    
    <div class="controls">
      <h3>Call Control</h3>
      <input type="text" id="destination" value="9999" placeholder="Destination (9999 for echo test)">
      <button id="callBtn" onclick="makeCall()" disabled>Call</button>
      <button id="hangupBtn" onclick="hangup()" disabled>Hangup</button>
      <button id="muteBtn" onclick="toggleMute()" disabled>Mute</button>
    </div>

    <div class="dial-pad">
      <button onclick="sendDTMF('1')">1</button>
      <button onclick="sendDTMF('2')">2</button>
      <button onclick="sendDTMF('3')">3</button>
      <button onclick="sendDTMF('4')">4</button>
      <button onclick="sendDTMF('5')">5</button>
      <button onclick="sendDTMF('6')">6</button>
      <button onclick="sendDTMF('7')">7</button>
      <button onclick="sendDTMF('8')">8</button>
      <button onclick="sendDTMF('9')">9</button>
      <button onclick="sendDTMF('*')">*</button>
      <button onclick="sendDTMF('0')">0</button>
      <button onclick="sendDTMF('#')">#</button>
    </div>

    <audio id="remoteAudio" autoplay playsinline></audio>
    <audio id="localAudio" muted playsinline></audio>

    <h3>Logs</h3>
    <div id="logs"></div>
  </div>

  <!-- Include Verto library from CDN or local -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery.jsonrpcclient@0.1.1/jquery.jsonrpcclient.min.js"></script>
  
  <script>
    let vertoHandle = null;
    let currentCall = null;
    let isMuted = false;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    window.addEventListener('load', () => {
      checkDevices();
    });

    async function checkDevices() {
      const deviceList = document.getElementById('deviceList');
      deviceList.innerHTML = '<p>–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤...</p>';
      
      try {
        // –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        log('‚úì –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –ø–æ–ª—É—á–µ–Ω–æ');
        
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ç–æ–∫
        stream.getTracks().forEach(track => track.stop());
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        
        if (audioInputs.length === 0) {
          deviceList.innerHTML = `
            <div class="error-box">
              <strong>‚ö†Ô∏è –ú–∏–∫—Ä–æ—Ñ–æ–Ω—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!</strong>
              <p>–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ:</p>
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>–ú–∏–∫—Ä–æ—Ñ–æ–Ω –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –∫–æ–º–ø—å—é—Ç–µ—Ä—É</li>
                <li>–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —Å–∏—Å—Ç–µ–º—ã</li>
                <li>–î—Ä—É–≥–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É</li>
              </ul>
            </div>
          `;
          log('‚ùå –ê—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
        } else {
          let html = `<div class="success-box"><strong>‚úì –ù–∞–π–¥–µ–Ω–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–≤: ${audioInputs.length}</strong><ul style="margin: 10px 0; padding-left: 20px;">`;
          audioInputs.forEach((device, index) => {
            html += `<li>${device.label || `–ú–∏–∫—Ä–æ—Ñ–æ–Ω ${index + 1}`} (ID: ${device.deviceId.substring(0, 20)}...)</li>`;
            log(`‚úì –ù–∞–π–¥–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω: ${device.label || `–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ ${index + 1}`}`);
          });
          html += '</ul></div>';
          deviceList.innerHTML = html;
        }
      } catch (error) {
        let errorMessage = '';
        let suggestions = '';
        
        switch(error.name) {
          case 'NotFoundError':
            errorMessage = '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>–ü–æ–¥–∫–ª—é—á–∏—Ç–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω –∫ –∫–æ–º–ø—å—é—Ç–µ—Ä—É</li>
                <li>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Windows (–ü–∞—Ä–∞–º–µ—Ç—Ä—ã ‚Üí –°–∏—Å—Ç–µ–º–∞ ‚Üí –ó–≤—É–∫)</li>
                <li>–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞</li>
              </ul>
            `;
            break;
          case 'NotAllowedError':
          case 'PermissionDeniedError':
            errorMessage = '–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–ø—Ä–µ—â—ë–Ω';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∏–∫–æ–Ω–∫—É –∑–∞–º–∫–∞/–∫–∞–º–µ—Ä—ã –≤ –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –±—Ä–∞—É–∑–µ—Ä–∞</li>
                <li>–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –¥–ª—è —ç—Ç–æ–≥–æ —Å–∞–π—Ç–∞</li>
                <li>–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π</li>
              </ul>
            `;
            break;
          case 'NotReadableError':
            errorMessage = '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>–ó–∞–∫—Ä–æ–π—Ç–µ –¥—Ä—É–≥–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω (Skype, Zoom, Discord –∏ —Ç.–¥.)</li>
                <li>–ó–∞–∫—Ä–æ–π—Ç–µ –¥—Ä—É–≥–∏–µ –≤–∫–ª–∞–¥–∫–∏ –±—Ä–∞—É–∑–µ—Ä–∞ —Å –¥–æ—Å—Ç—É–ø–æ–º –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É</li>
                <li>–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–æ–º–ø—å—é—Ç–µ—Ä, –µ—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è</li>
              </ul>
            `;
            break;
          default:
            errorMessage = error.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
            suggestions = `
              <ul style="margin: 10px 0; padding-left: 20px;">
                <li>–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π –±—Ä–∞—É–∑–µ—Ä (Chrome, Firefox, Edge)</li>
                <li>–û–±–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ä—Å–∏–∏</li>
                <li>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–∞</li>
              </ul>
            `;
        }
        
        deviceList.innerHTML = `
          <div class="error-box">
            <strong>‚ùå –û—à–∏–±–∫–∞: ${errorMessage}</strong>
            <p><code>–¢–∏–ø –æ—à–∏–±–∫–∏: ${error.name}</code></p>
            <p><strong>–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:</strong></p>
            ${suggestions}
          </div>
        `;
        log(`‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: ${error.name} - ${error.message}`);
        console.error('Microphone error details:', error);
      }
    }

    async function testMicrophone() {
      log('–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        log('‚úì –ú–∏–∫—Ä–æ—Ñ–æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç! –¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω');
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∑–≤—É–∫–∞
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        const microphone = audioContext.createMediaStreamSource(stream);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        microphone.connect(analyser);
        
        let checkCount = 0;
        const checkInterval = setInterval(() => {
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
          log(`–£—Ä–æ–≤–µ–Ω—å –∑–≤—É–∫–∞: ${Math.round(average)}/255 ${average > 10 ? 'üîä' : 'üîá'}`);
          
          checkCount++;
          if (checkCount >= 5) {
            clearInterval(checkInterval);
            stream.getTracks().forEach(track => track.stop());
            audioContext.close();
            log('‚úì –¢–µ—Å—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –∑–∞–≤–µ—Ä—à—ë–Ω');
          }
        }, 500);
        
      } catch (error) {
        log(`‚ùå –¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω: ${error.name} - ${error.message}`);
        console.error('Microphone test failed:', error);
      }
    }

    // Simple Verto implementation (simplified for demo)
    class VertoClient {
      constructor(config) {
        this.config = config;
        this.ws = null;
        this.sessid = null;
        this.pc = null;
        this.currentCallID = null;
      }

      connect() {
        return new Promise((resolve, reject) => {
          log('Connecting to ' + this.config.socketUrl);
          this.ws = new WebSocket(this.config.socketUrl);
          
          this.ws.onopen = () => {
            log('WebSocket connected');
            this.login().then(resolve).catch(reject);
          };

          this.ws.onerror = (error) => {
            log('WebSocket error: ' + error);
            reject(error);
          };

          this.ws.onmessage = (event) => {
            this.handleMessage(JSON.parse(event.data));
          };

          this.ws.onclose = () => {
            log('WebSocket closed');
            updateStatus('disconnected');
          };
        });
      }

      login() {
        const sessid = this.generateSessid();
        this.sessid = sessid;
        
        log(`Attempting login as ${this.config.login}@${this.config.domain}`);
        
        return this.sendRequest('login', {
          login: `${this.config.login}@${this.config.domain}`,
          passwd: this.config.password,
          sessid: sessid
        }).then((response) => {
          log(`Login request sent with sessid: ${sessid}`);
          return response;
        });
      }

      call(destination) {
        log('Calling ' + destination);
        
        const callID = this.generateSessid();
        
        const pc = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:localhost:3478', username: 'webrtc', credential: 'webrtcpass' }
          ]
        });

        this.pc = pc;
        this.currentCallID = callID;

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            log('ICE candidate: ' + event.candidate.candidate);
          } else {
            log('ICE gathering complete');
          }
        };

        pc.ontrack = (event) => {
          log('Remote stream received');
          document.getElementById('remoteAudio').srcObject = event.streams[0];
        };

        log('Requesting microphone access...');
        return navigator.mediaDevices.getUserMedia({ audio: true, video: false })
          .then(stream => {
            log('‚úì Local stream obtained');
            document.getElementById('localAudio').srcObject = stream;
            stream.getTracks().forEach(track => {
              pc.addTrack(track, stream);
              log(`Added track: ${track.kind} (${track.label})`);
            });
            return pc.createOffer();
          })
          .catch(error => {
            log(`‚ùå Failed to get microphone: ${error.name} - ${error.message}`);
            throw error;
          })
          .then(offer => {
            log('Offer created');
            return pc.setLocalDescription(offer);
          })
          .then(() => {
            return this.sendRequest('verto.invite', {
              sessid: this.sessid,
              sdp: this.pc.localDescription.sdp,
              callID: callID,
              dialogParams: {
                destination_number: destination,
                caller_id_name: this.config.login,
                caller_id_number: this.config.login,
                useVideo: false,
                useStereo: false,
                screenShare: false,
                useCamera: false,
                useMic: true,
                dedEnc: false,
                mirrorInput: false
              }
            });
          });
      }

      hangup() {
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
        if (this.currentCallID) {
          return this.sendRequest('verto.bye', {
            sessid: this.sessid,
            callID: this.currentCallID
          });
        }
      }

      sendDTMF(digit) {
        if (this.pc) {
          const sender = this.pc.getSenders().find(s => s.track && s.track.kind === 'audio');
          if (sender && sender.dtmf) {
            sender.dtmf.insertDTMF(digit);
            log('Sent DTMF: ' + digit);
          }
        }
      }

      sendRequest(method, params) {
        const msg = {
          jsonrpc: '2.0',
          method: method,
          params: params || {},
          id: Date.now()
        };
        
        log('Sending: ' + method);
        this.ws.send(JSON.stringify(msg));
        
        return new Promise((resolve, reject) => {
          // Simple timeout-based resolution (proper implementation would track request IDs)
          setTimeout(() => resolve(), 1000);
        });
      }

      handleMessage(msg) {
        log('Received: ' + JSON.stringify(msg));
        console.log('Full Verto message:', msg);
        
        if (msg.error) {
          log(`‚ùå Error: ${msg.error.message} (code: ${msg.error.code})`);
          console.error('Verto error details:', msg.error);
          return;
        }
        
        if (msg.method === 'verto.answer' && msg.params && msg.params.sdp) {
          log('Setting remote description from answer');
          this.pc.setRemoteDescription({
            type: 'answer',
            sdp: msg.params.sdp
          }).then(() => {
            log('‚úì Call answered and connected');
          }).catch(err => {
            log(`‚ùå Failed to set remote description: ${err}`);
          });
        } else if (msg.method === 'verto.bye') {
          log('Call ended by remote');
          if (this.pc) {
            this.pc.close();
            this.pc = null;
          }
          updateCallButtons(false);
        } else if (msg.result) {
          if (msg.result.message === 'logged in' || msg.result.message) {
            this.sessid = msg.result.sessid || this.sessid;
            log(`‚úì ${msg.result.message} - sessid: ${this.sessid}`);
            updateStatus('connected');
          } else {
            log(`Result: ${JSON.stringify(msg.result)}`);
          }
        }
      }

      generateSessid() {
        return Math.random().toString(36).substring(2, 15);
      }

      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
      }
    }

    function log(message) {
      const logs = document.getElementById('logs');
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = new Date().toLocaleTimeString() + ' - ' + message;
      logs.appendChild(entry);
      logs.scrollTop = logs.scrollHeight;
    }

    function updateStatus(status) {
      const statusEl = document.getElementById('status');
      statusEl.className = 'status ' + status;
      statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      
      document.getElementById('connectBtn').disabled = (status === 'connected');
      document.getElementById('disconnectBtn').disabled = (status === 'disconnected');
      document.getElementById('callBtn').disabled = (status !== 'connected');
    }

    function updateCallButtons(inCall) {
      document.getElementById('callBtn').disabled = inCall;
      document.getElementById('hangupBtn').disabled = !inCall;
      document.getElementById('muteBtn').disabled = !inCall;
    }

    function connect() {
      const server = document.getElementById('server').value;
      const extension = document.getElementById('extension').value;
      const password = document.getElementById('password').value;
      
      updateStatus('connecting');
      
      vertoHandle = new VertoClient({
        socketUrl: server,
        login: extension,
        password: password,
        domain: server.includes('localhost') ? 'auto' : 'localhost'  // –ò—Å–ø–æ–ª—å–∑—É–µ–º 'auto' –¥–ª—è localhost
      });
      
      vertoHandle.connect()
        .then(() => {
          log('Successfully connected and logged in');
        })
        .catch(error => {
          log('Connection failed: ' + error);
          updateStatus('disconnected');
        });
    }

    function disconnect() {
      if (vertoHandle) {
        vertoHandle.disconnect();
        vertoHandle = null;
      }
      updateStatus('disconnected');
      updateCallButtons(false);
    }

    function makeCall() {
      const destination = document.getElementById('destination').value;
      if (vertoHandle && destination) {
        log(`Initiating call to ${destination}...`);
        vertoHandle.call(destination)
          .then(() => {
            log('‚úì Call initiated to ' + destination);
            updateCallButtons(true);
          })
          .catch(error => {
            log(`‚ùå Call failed: ${error.name} - ${error.message}`);
            console.error('Call error:', error);
            alert(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫:\n${error.name}: ${error.message}\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.`);
          });
      }
    }

    function hangup() {
      if (vertoHandle) {
        vertoHandle.hangup()
          .then(() => {
            log('Call ended');
            updateCallButtons(false);
          });
      }
    }

    function toggleMute() {
      if (vertoHandle && vertoHandle.pc) {
        const audioTrack = document.getElementById('localAudio').srcObject.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          document.getElementById('muteBtn').textContent = isMuted ? 'Unmute' : 'Mute';
          log(isMuted ? 'Muted' : 'Unmuted');
        }
      }
    }

    function sendDTMF(digit) {
      if (vertoHandle) {
        vertoHandle.sendDTMF(digit);
      }
    }

    // Initialize
    log('WebRTC client ready');
    updateStatus('disconnected');
  </script>
</body>
</html>

=== РЕАЛИЗАЦИЯ ЗАПИСИ ЗВОНКОВ ===
Дата: 27 декабря 2025

ВНЕСЕННЫЕ ИЗМЕНЕНИЯ:
--------------------

1. **Исправлена конфигурация Asterisk** (asterisk-config/extensions.conf)
   ✅ Убрана опечатка `NoOp(MixMonitor start ${__REC_FULLPATH})q` → правильно без `q`
   ✅ Упрощена логика проверки: заменен ExecIf на GotoIf для предотвращения повторного запуска
   ✅ Запись сохраняется в: `/var/lib/asterisk/recordings/{UNIQUEID}.wav`

2. **Создан RecordingsController** (apps/back/src/app/modules/calls/controllers/recordings.controller.ts)
   ✅ GET `/api/calls/recordings/:uniqueId` - скачивание WAV файла
   ✅ GET `/api/calls/recordings/exists/:uniqueId` - проверка существования записи
   ✅ Защита от path traversal (санитизация uniqueId)
   ✅ Правильные HTTP заголовки для скачивания файла

3. **Автоматическое заполнение recordingUrl** (call-aggregation.service.ts)
   ✅ Метод `buildRecordingUrl()` генерирует URL для каждого summary
   ✅ Формат: `/api/calls/recordings/{uniqueId}`
   ✅ Сохраняется в поле `recordingUrl` таблицы `call_summaries`

4. **Зарегистрирован контроллер** (calls.module.ts)
   ✅ RecordingsController добавлен в массив controllers

5. **Создана документация** (data/asterisk/recordings/README.md)
   ✅ Описание работы записи
   ✅ Формат файлов и доступ
   ✅ Troubleshooting инструкции

DOCKER КОНФИГУРАЦИЯ:
---------------------
Volume уже смонтирован в docker-compose.yml:
```yaml
volumes:
  - ./data/asterisk/recordings:/var/lib/asterisk/recordings:rw
```

ASTERISK КОНФИГУРАЦИЯ:
-----------------------
Subroutine `sub-record-start` вызывается во всех extensions:
- 1000 (IVR entry)
- 6000 (Dynamic IVR)
- 100 (Support queue)
- 2001-2004 (Operator extensions)
- queue_* (Queue patterns)
- support, microsip (Named queues)

Формат записи:
```
exten => s,n,Set(REC_FILENAME=${UNIQUEID})
exten => s,n,MixMonitor(${RECORDINGS_DIR}/${REC_FILENAME}.wav,b)
```

API ENDPOINTS:
--------------
1. Скачать запись:
   GET /api/calls/recordings/:uniqueId
   Response: audio/wav file
   
2. Проверить существование:
   GET /api/calls/recordings/exists/:uniqueId
   Response: { exists: boolean, size?: number, path?: string }

3. Список звонков с URL записей:
   GET /api/cdr?... 
   GET /api/calls/analytics/...
   → Поле `recordingUrl` в CallSummary уже заполнено

ТЕСТИРОВАНИЕ:
-------------
1. Перезапустить Asterisk контейнер:
   ```
   docker-compose restart asterisk
   ```

2. Сделать тестовый звонок (например, на 1000 или 100)

3. Проверить, что файл создан:
   ```
   ls -lh data/asterisk/recordings/
   ```

4. Проверить через API:
   ```
   curl http://localhost:3000/api/calls/recordings/exists/1735307123.45
   ```

5. Скачать запись:
   ```
   curl http://localhost:3000/api/calls/recordings/1735307123.45 -o test.wav
   ```

6. Проверить в CallSummary:
   ```sql
   SELECT uniqueId, recordingUrl FROM call_summaries ORDER BY createdAt DESC LIMIT 10;
   ```

ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ:
---------------------
Можно переопределить путь к записям:
```
RECORDINGS_PATH=/custom/path/to/recordings
```

По умолчанию: `/var/lib/asterisk/recordings`

ВАЖНО:
------
- Записи создаются ТОЛЬКО при наличии вызова `Gosub(sub-record-start,s,1())`
- Файлы создаются после завершения звонка (MixMonitor закрывает файл)
- Размер файла зависит от длительности звонка (примерно 100KB на минуту WAV)
- Рекомендуется настроить ротацию/архивацию старых записей

NEXT STEPS:
-----------
- [ ] Добавить автоматическую очистку старых записей (>90 дней)
- [ ] Интеграция с S3/облачным хранилищем
- [ ] Добавить транскрипцию записей (Speech-to-Text)
- [ ] Добавить плеер записей в UI (frontend)
- [ ] Метрики по размеру записей и использованию диска
